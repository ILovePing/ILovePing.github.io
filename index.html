<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="陈正荣的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Bbb&#39;s NoteBook">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Bbb&#39;s NoteBook">
<meta property="og:description" content="陈正荣的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bbb&#39;s NoteBook">
<meta name="twitter:description" content="陈正荣的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Bbb's NoteBook</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Bbb's NoteBook</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">cherrish everytime</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/15/埋点热力图绘制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/15/埋点热力图绘制/" itemprop="url">埋点热力图绘制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-15T15:17:16+08:00">
                2021-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>iframe</li>
<li>findDom</li>
<li>canvas 放射渐变圆</li>
<li>权重（密度）算法</li>
<li>颜色映射</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/15/深拷贝实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/15/深拷贝实现/" itemprop="url">深拷贝实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-15T15:16:06+08:00">
                2021-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>前言：<br>ECMAScript 中基本数据类型都是存储在栈中，是有固定字节长度的，由系统自动释放；</p>
<p>引用类型都是存储在堆中，是动态的字节长度，也不会自动释放，引用类型变量值实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址，因此两个引用类型的===比较其实比较的是两者的堆内存地址，就算两个值都是<code>{a:1}</code>，但是在内存中的地址是不同的，因此<code>{a:1} === {a:1}</code></p>
<p>so,如下所示，可以看到赋值 a 给 b 的也是一个内存地址而已，ab 两者最终指向的都是一个内存堆，通过任意一个引用值改变内存堆中的原始数值都是会影响另外一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;; <span class="comment">// a保存了一个空对象的实例</span></span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// a和b都指向了这个空对象</span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">"jozo"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// 'jozo'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">// 'jozo'</span></span><br></pre></td></tr></table></figure>
<p>obviously，你可能会认为这就是最基础的拷贝。NO！这只是引用而已,not copy.<br>拷贝是将 B 对象拷贝到 A 对象中，而深拷贝和浅拷贝的区别就是两者前者将 B 里面的子对象也拷贝给了 A。如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (src.hasOwnProperty(key)) &#123;</span><br><span class="line">      target[key] = src[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>: <span class="string">"cxq"</span>, <span class="attr">age</span>: <span class="number">12</span>, <span class="attr">pockets</span>: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]] &#125;;</span><br><span class="line"><span class="keyword">const</span> b = a;</span><br><span class="line"><span class="keyword">const</span> c = shallowCopy(a);</span><br><span class="line"></span><br><span class="line">b.name = <span class="string">"rick"</span>;</span><br><span class="line">b.pockets[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">c.age = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/13430709/69207354-6a000500-0b8a-11ea-9b89-9342e93490ca.png" alt="image"></p>
<p>c 是浅拷贝 a 的一个新对象，可以看到 c 对象的基本数据类型 age 是一个新的内存栈，因此修改 age 值，a 的 age 值不会跟着变化，同 a 无关联了；而修改 c 对象的 pockets，a、b 对象的属性都被修改了，可见 abc 的 pockets 最终是指向同一个内存堆的。<br>因此通过浅复制一层 a 得到的 c 对象中的引用类型实际上就是一个内存地址最终指向的是同一个内存堆。</p>
<p>so，想要彻底分离 copy 出来的对象，应当使用深拷贝，即不止第一层，每一层都需要进行拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">src, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(src)) <span class="keyword">return</span> src; <span class="comment">// 基本类型</span></span><br><span class="line">  <span class="keyword">const</span> typeTag = <span class="built_in">Object</span>.prototype.toString.call(src);</span><br><span class="line">  <span class="keyword">let</span> target = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (isDeepObject.includes(typeTag)) &#123;</span><br><span class="line">    <span class="comment">// 可深层嵌套的对象类型</span></span><br><span class="line">    target = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(src));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cloneSimpleObject(src, typeTag);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用weakMap 防止循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (map.get(src)) &#123;</span><br><span class="line">    <span class="keyword">return</span> src;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    map.set(src, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ([mapTag, setTag].includes(typeTag)) &#123;</span><br><span class="line">    <span class="keyword">const</span> isMap = typeTag === mapTag;</span><br><span class="line">    src.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isMap) &#123;</span><br><span class="line">        target.set(key, deepClone(value, map));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target.add(deepClone(value, map));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> keys = typeTag === arrayTag ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(src);</span><br><span class="line">  (keys || src).forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">      key = value;</span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = deepClone(src[key], map);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSimpleObject</span>(<span class="params">src, typeTag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _constructor = src.constructor;</span><br><span class="line">  <span class="keyword">switch</span> (typeTag) &#123;</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">    <span class="keyword">case</span> errorTag:</span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _constructor(src);</span><br><span class="line">    <span class="keyword">case</span> symbolTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(src));</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> cloneFunction(src);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// lodash的处理是对于function 直接返回</span></span><br><span class="line">  <span class="comment">// 如果继续深究 可以用正则将params 和 函数体分离出来 使用new Function(...prams,body)生成新实例，如下</span></span><br><span class="line">  <span class="keyword">const</span> functionStr = src.toString();</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>; <span class="comment">// 多行匹配 + 后行断言?&lt;= + 先行断言?=</span></span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s*&#123;)/</span>;</span><br><span class="line">  <span class="keyword">if</span> (src.prototype) &#123;</span><br><span class="line">    <span class="keyword">const</span> params = paramReg.exec(functionStr);</span><br><span class="line">    <span class="keyword">const</span> bodys = bodyReg.exec(functionStr);</span><br><span class="line">    <span class="keyword">if</span> (bodys) &#123;</span><br><span class="line">      <span class="comment">// 函数体不为空</span></span><br><span class="line">      <span class="keyword">if</span> (params) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">          ...params[<span class="number">0</span>].split(<span class="string">","</span>).map(<span class="function">(<span class="params">p</span>) =&gt;</span> p.trim()),</span><br><span class="line">          bodys[<span class="number">0</span>]</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(bodys[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 箭头函数直接eval返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(functionStr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PRIMITIVES = [</span><br><span class="line">  <span class="string">"number"</span>,</span><br><span class="line">  <span class="string">"string"</span>,</span><br><span class="line">  <span class="string">"boolean"</span>,</span><br><span class="line">  <span class="string">"symbol"</span>,</span><br><span class="line">  <span class="string">"null"</span>,</span><br><span class="line">  <span class="string">"undefined"</span>,</span><br><span class="line">]; <span class="comment">// 基础类型</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *** 可嵌套对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">"[object Object]"</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">"[object Array]"</span>;</span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">"[object Map]"</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">"[object Set]"</span>;</span><br><span class="line"><span class="keyword">const</span> argsTag = <span class="string">"[object Arguments]"</span>;</span><br><span class="line"><span class="keyword">const</span> isDeepObject = [objectTag, arrayTag, mapTag, setTag, argsTag];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *** 不可嵌套对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">"[object RegExp]"</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">"[object Error]"</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">"[object Function]"</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">"[object Date]"</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">"[object Number]"</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">"[object String]"</span>;</span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">"[object Boolean]"</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">"[object Symbol]"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有以下二进制数组类型等，不写了。。。</span></span><br><span class="line"><span class="keyword">const</span> arrayBufferTag = <span class="string">"[object ArrayBuffer]"</span>;</span><br><span class="line"><span class="keyword">const</span> dataViewTag = <span class="string">"[object DataView]"</span>;</span><br><span class="line"><span class="keyword">const</span> float32Tag = <span class="string">"[object Float32Array]"</span>;</span><br><span class="line"><span class="keyword">const</span> float64Tag = <span class="string">"[object Float64Array]"</span>;</span><br><span class="line"><span class="keyword">const</span> int8Tag = <span class="string">"[object Int8Array]"</span>;</span><br><span class="line"><span class="keyword">const</span> int16Tag = <span class="string">"[object Int16Array]"</span>;</span><br><span class="line"><span class="keyword">const</span> int32Tag = <span class="string">"[object Int32Array]"</span>;</span><br><span class="line"><span class="keyword">const</span> uint8Tag = <span class="string">"[object Uint8Array]"</span>;</span><br><span class="line"><span class="keyword">const</span> uint8ClampedTag = <span class="string">"[object Uint8ClampedArray]"</span>;</span><br><span class="line"><span class="keyword">const</span> uint16Tag = <span class="string">"[object Uint16Array]"</span>;</span><br><span class="line"><span class="keyword">const</span> uint32Tag = <span class="string">"[object Uint32Array]"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src !== <span class="literal">null</span> &amp;&amp; [<span class="string">"object"</span>, <span class="string">"function"</span>].includes(<span class="keyword">typeof</span> src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/13430709/69615178-6fb88780-106f-11ea-9d29-ef8602c5034d.png" alt="deepCopy"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/15/Js-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/15/Js-基础/" itemprop="url">Js 基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-15T15:13:35+08:00">
                2021-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>判断是否在视口内：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ele.getBoundingClientRect().top &gt; <span class="built_in">window</span>.innerHeight; <span class="comment">// 元素在当前屏下面</span></span><br><span class="line"></span><br><span class="line">ele.getBoundingClientRect().bottom &lt; <span class="number">0</span>; <span class="comment">// 元素在当前屏上面</span></span><br></pre></td></tr></table></figure>
<p><a href="https://app.leanboard.io/board/c90672de-658b-4058-a4cf-adb28ad4bad5" target="_blank" rel="noopener">https://app.leanboard.io/board/c90672de-658b-4058-a4cf-adb28ad4bad5</a></p>
<ul>
<li>dom bom window document 概念</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOM 是为了操作文档出现的 API，<span class="built_in">document</span> 是其的一个对象；</span><br><span class="line">BOM 是为了操作浏览器出现的 API，<span class="built_in">window</span> 是其的一个对象。</span><br></pre></td></tr></table></figure>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><h3 id="IE8：XDR-XDomainRequest"><a href="#IE8：XDR-XDomainRequest" class="headerlink" title="IE8：XDR(XDomainRequest)"></a>IE8：XDR(XDomainRequest)</h3><ul>
<li>通信不携带 cookie</li>
<li>只能设置请求头里的 Content-Type 字段</li>
<li>不支持访问响应头</li>
<li>只支持 GET 与 POST</li>
</ul>
<h3 id="其他浏览器：XHR-直接支持"><a href="#其他浏览器：XHR-直接支持" class="headerlink" title="其他浏览器：XHR 直接支持"></a>其他浏览器：XHR 直接支持</h3><ul>
<li><p>不能使用 setRequestHeader 设置自定义头部</p>
<pre><code>- 场景：
</code></pre><p>报错：“not allowed by Access-Control-Allow-Headers in preflight response”<br>措施：服务端设置 Access-Control-Allow-Headers 即可接触限制</p>
</li>
<li><p>不能发送和接受 cookie</p>
<ul>
<li><p>设置 withCredentials 字段即可携带 cookie</p>
<ul>
<li>场景：antd 文件上传 配置 withCredentials 即可在上传文件的时候进行身份认证</li>
</ul>
</li>
</ul>
</li>
<li><p>调用 getAllResponseHeaders 永远返回空字符串</p>
</li>
</ul>
<h3 id="对跨域请求出于安全的浏览器实现"><a href="#对跨域请求出于安全的浏览器实现" class="headerlink" title="对跨域请求出于安全的浏览器实现"></a>对跨域请求出于安全的浏览器实现</h3><ul>
<li><p>对服务器数据可能产生副作用的请求（非简单请求）需要先进行一次 OPTIONS 方法的预检请求（preflight request）</p>
<ul>
<li><p>简单请求</p>
<ul>
<li><p>REQUEST METHOD</p>
<ul>
<li>GET、HEAD、POST</li>
</ul>
</li>
<li><p>CONTENT-TYPE 属于</p>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>applacation/x-www-form-urlencoded</li>
</ul>
</li>
</ul>
</li>
<li><p>非简单请求（满足其中之一条件即可）</p>
<ul>
<li><p>REQUEST METHOD</p>
<ul>
<li>PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH</li>
</ul>
</li>
<li><p>人为设置除以下请求头以外的 header 字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li><p>CONTENT-TYPE 不属于</p>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>applacation/x-www-form-urlencoded</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="图像-Ping"><a href="#图像-Ping" class="headerlink" title="图像 Ping"></a>图像 Ping</h2><h3 id="img-src-属性对不同域资源不做限制"><a href="#img-src-属性对不同域资源不做限制" class="headerlink" title="img src 属性对不同域资源不做限制"></a>img src 属性对不同域资源不做限制</h3><ul>
<li><p>缺点</p>
<ul>
<li>只能 get 请求</li>
<li>单向的，无法处理 responseText</li>
</ul>
</li>
<li><p>场景</p>
<ul>
<li>埋点</li>
</ul>
</li>
</ul>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><h3 id="script-src-属性对不同域资源不做限制"><a href="#script-src-属性对不同域资源不做限制" class="headerlink" title="script src 属性对不同域资源不做限制"></a>script src 属性对不同域资源不做限制</h3><ul>
<li><p>原理</p>
<pre><code>- get请求query传callback=JS定义的回调参数名称假定为func
</code></pre><p>服务端 responseText=func(服务端插入 data)<br>至此 JS 接收到请求会直接执行该方法，参数即服务端返回 data</p>
</li>
<li><p>优点</p>
<ul>
<li>双向的</li>
<li>可以直接处理 responseText</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>加载其他域代码 不安全</li>
<li>不好确定请求是否失败 H5 onerror 方法兼容性不好</li>
</ul>
</li>
</ul>
<h2 id="COMET"><a href="#COMET" class="headerlink" title="COMET"></a>COMET</h2><h3 id="释义：服务器向页面推送数据（单向的）的一种技术"><a href="#释义：服务器向页面推送数据（单向的）的一种技术" class="headerlink" title="释义：服务器向页面推送数据（单向的）的一种技术"></a>释义：服务器向页面推送数据（单向的）的一种技术</h3><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li>长轮询</li>
<li><p>流</p>
<ul>
<li>XHR 监听 xhr.readyState === 3（此时为接收状态）周期性的往先前接收到的数据里拼接。</li>
</ul>
</li>
</ul>
<h3 id="SSE（EventSource）"><a href="#SSE（EventSource）" class="headerlink" title="SSE（EventSource）"></a>SSE（EventSource）</h3><ul>
<li><p>释义：围绕 COMET 交互实现的 API</p>
<ul>
<li>服务器响应 MIMETYPE 必须为 text/event-stream</li>
<li>创建到服务端的单向连接，服务器可以发送任意数量的数据</li>
<li>支持短轮询，长轮询和 HTTP 流</li>
<li><p>能在断开连接时自动确定何时重新连接</p>
<ul>
<li>每次请求都会返回一个 event-id，断开连接后，下次连接重新发送 Last-Event-Id 定位续传位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="WEBSOCKET"><a href="#WEBSOCKET" class="headerlink" title="WEBSOCKET"></a>WEBSOCKET</h2><h3 id="提供双向的全双工通信的持久连接"><a href="#提供双向的全双工通信的持久连接" class="headerlink" title="提供双向的全双工通信的持久连接"></a>提供双向的全双工通信的持久连接</h3><h3 id="（ws-wss-）协议"><a href="#（ws-wss-）协议" class="headerlink" title="（ws:// | wss://）协议"></a>（ws:// | wss://）协议</h3><ul>
<li>自定义的协议相较于 Http 协议字节开销小很多</li>
</ul>
<ul>
<li>ECMA-262 第五版在定义只有内部才用的特性（attribute）时，描述了属性的（property）的属性。</li>
<li>这些特性是为了实现 js 引擎使用的，所以 js 不能直接访问它们，所以规范中把它们放在了两对方括号中，例如[[Configurable]]。</li>
<li><p>ECMAScript 中有两种属性：<strong>数据属性</strong>和<strong>访问器属性</strong>。 - - -<br>1、数据属性（个人理解，数据属性包含一个数据值的位置，直接分配内存 allocation，在该内存上进行读取写入操作。）</p>
<pre><code>* `[[Configurable]]` 通过字面量定义时默认为true，通过`Object.defineProperty`时默认为false。表示能否通过delete删除属性从而重新定义属性（**此处属性指的都是对象属性，即遍历中的key，不是所谓的对象值value**），能否修改属性的特性，能否把属性修改为访问器属性。
</code></pre><p><img src="https://user-images.githubusercontent.com/13430709/68460528-0fd67a00-0243-11ea-9035-2d9f64cf8491.png" alt="image"></p>
<pre><code>* `[[Enumrable]]` 通过字面量定义时默认为true，通过`Object.defineProperty`时默认为false，表示能否通过for in 循环遍历属性。
</code></pre></li>
</ul>
<pre><code>* `[[writable]]` 通过字面量定义时默认为true，通过`Object.defineProperty`时默认为false，表示能否修改属性的值。


* `[[value]]` 默认为undefined，表示当前属性数据值，读取和赋值属性值就是在这个位置上操作。

- - -
2、 访问器属性
（不能直接定义，必须使用Object.definedProperty来定义.
个人理解，访问器属性不包含数据值，**它是自身没有值的，可以理解为一个接口**指的是读取/写入该访问器属性这一过程的一些行为逻辑。）

* `[[Configurable]]` 同上
* `[[Enumrable]]` 同上
* `[[Get]]` 在读取属性值时的函数，默认undefined
* `[[Set]]` 在写入属性值时的函数，默认undefined

在`Object.definedProperty` API之前，使用两个非标准方法`__defineGetter__()`和`__defineSetter__()`
</code></pre><hr>
<p><code>Object.defineProperties</code><br>定义多个属性，可以同时为一个对象定义多个数据属性和访问器属性。<br><code>Object.getOwnPropertyDescriptors</code><br>获取对象所有数据属性和访问器属性的属性。</p>
<h3 id="对象创建与继承"><a href="#对象创建与继承" class="headerlink" title="对象创建与继承"></a>对象创建与继承</h3><ul>
<li>创建对象可以直接通过字面量创建<code>const a = {}</code>也可以通过构造函数<code>const a = new Object()</code>来创建<br>考虑封装减少代码重复，所以万能的程序员想到了各种模式实现方法的创建。</li>
</ul>
<h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><hr>
<ul>
<li>工厂模式<br><img src="https://user-images.githubusercontent.com/13430709/68575652-752aa500-04a7-11ea-9287-277a7944ff90.png" alt="image"><br>缺点：无法识别对象类型（都是 Object new 出来的）</li>
<li>构造函数模式<br><img src="https://user-images.githubusercontent.com/13430709/68576945-14e93280-04aa-11ea-98fa-6816a4e1d774.png" alt="image"><br>缺点：实例中对函数方法都是和每个实例一一对应的，一是浪费内存，二是每次都得定义一遍。</li>
<li>原型模式<br><img src="https://user-images.githubusercontent.com/13430709/68578053-39460e80-04ac-11ea-8dc4-eab7f7f5b118.png" alt="image"><br>简易写法（不推荐）：<br><img src="https://user-images.githubusercontent.com/13430709/68579506-40bae700-04af-11ea-816e-51c4ca971a40.png" alt="image"><br>导致问题： constructor 丢失<br>解决方法：重新手动指定 constructor<br><img src="https://user-images.githubusercontent.com/13430709/68579689-a909c880-04af-11ea-9a5f-ef3405478788.png" alt="image"><br>导致问题：这样指定会导致 constructor 也是[[Enumrable]]为 true，遍历时可以枚举出来的<br>解决方法：使用 Object.defineProperty<br><img src="https://user-images.githubusercontent.com/13430709/68579797-fd14ad00-04af-11ea-9c40-7ee3fd03caf0.png" alt="image"><br>该模式缺点：单独使用原型模式共享所有的数据属性。</li>
<li>组合使用构造函数模式和原形模式（推荐，主流实现）<br><img src="https://user-images.githubusercontent.com/13430709/68580124-a9ef2a00-04b0-11ea-8684-099e5a1a0a8b.png" alt="image"><br>小缺点：其他语言 er 看的不舒服，方法定义在构造函数外面…</li>
<li>动态原型模式<br><img src="https://user-images.githubusercontent.com/13430709/68580201-d014ca00-04b0-11ea-9983-2610fb20911f.png" alt="image"></li>
<li>寄生构造函数模式(不推荐)<br><img src="https://user-images.githubusercontent.com/13430709/68580608-aa3bf500-04b1-11ea-953e-b93d5413f1bc.png" alt="image"></li>
<li>稳妥构造函数模式(与寄生构造类似，只是不使用 this 获取变量，适合在一些安全的环境中使用该模式)<br><img src="https://user-images.githubusercontent.com/13430709/68580738-eec79080-04b1-11ea-9b2c-5e0685d47bdd.png" alt="image"></li>
</ul>
<h4 id="对象继承-js-中就是依靠原型链实现「实现继承的」"><a href="#对象继承-js-中就是依靠原型链实现「实现继承的」" class="headerlink" title="对象继承(js 中就是依靠原型链实现「实现继承的」)"></a>对象继承(js 中就是依靠原型链实现「实现继承的」)</h4><hr>
<ul>
<li><p>原型链<br><img src="https://user-images.githubusercontent.com/13430709/68635622-1e1ee180-0534-11ea-9850-b782e7f51e93.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/68586666-1faec200-04c0-11ea-914c-fa105a0a78f0.png" alt="image"><br>问题 1： 原型链上父类构造函数如果定义了引用类型值（比如数组），那么对于使用子构造函数的每个实例，向上沿着原型链查找父类的引用类型值时指向的都是同一个原型属性。那么一个实例对于原型上的引用类型修改势必会反应到另一个实例上。如下图所示：<br><img src="https://user-images.githubusercontent.com/13430709/68636198-ace02e00-0535-11ea-9354-036407652c10.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/68636182-a5b92000-0535-11ea-8f27-5fb294cb29e4.png" alt="image"><br>问题 2：可以看到单独使用原型链继承的话 无法向超类传参数，比如我 new 一个 Girl 继承自 Mankind，不能通过 Mankind 构造函数初始化 name，weight 和 height。</p>
</li>
<li><p>借用构造函数（使用 call/apply 借用超类构造函数）<br><img src="https://user-images.githubusercontent.com/13430709/68637553-efa40500-0539-11ea-9111-675fe32c0c77.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/68637547-ec107e00-0539-11ea-9e36-b051d1024927.png" alt="image"><br>缺点：单独使用的话，就是单纯的执行父类构造函数，绑定当前构造函数的 this 而已，那么就回到了最开始上面的「构造函数模式创建对象」，缺点同理。</p>
</li>
<li><p>组合继承（推荐，最常用的继承方式，借用构造函数继承属性，通过原型链继承方法）<br><img src="https://user-images.githubusercontent.com/13430709/68638458-9b4e5480-053c-11ea-8490-02f545866485.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/68638410-70fc9700-053c-11ea-8ade-e24a8dcefc52.png" alt="image"><br>缺点：<strong>两次调用超类构造函数，</strong><br><img src="https://user-images.githubusercontent.com/13430709/68645550-613c7d00-0553-11ea-9444-eb0dd51d99ed.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/68645620-921cb200-0553-11ea-846a-3eab7abab77a.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/68645951-a6ad7a00-0554-11ea-9ba6-d71c997489f1.png" alt="image"></p>
</li>
<li><p>原型式继承<br>没有必要兴师动众使用构造函数创建对象，只不过想抽离公用代码，通过一个对西那个创建几个类似的对象时，可以考虑使用原型式继承，ES6 新增<code>Object.create</code>方法规范化了该继承方式。<br><img src="https://user-images.githubusercontent.com/13430709/68638865-db620700-053d-11ea-8bef-580407235214.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/68638858-d69d5300-053d-11ea-9e6b-4d2a4df28c28.png" alt="image"><br>缺点：引用类型值始终是被共享的，就跟原型模式创建对象一样，一处改动，其他实例跟着受影响。</p>
</li>
<li><p>寄生式继承<br><img src="https://user-images.githubusercontent.com/13430709/68639465-9c34b580-053f-11ea-98ab-8f5a7c8067cc.png" alt="image"><br>缺点：一个缺点同上，引用类型值共享，另一个缺点是函数复用率底，同构造函数模式。</p>
</li>
<li><p>寄生组合式继承<br>由于上面列过的 组合继承的缺点（执行两次超类构造），因此可以使用寄生组合继承规避该缺点。<br>原理：在组合继承中，其实不必为了指定子类型的原型而去调用超类的构造函数，即<code>Woman.prototype = new Mankind();</code>其实没必要的，我们只不过是为了一个超类原型的一个副本，因此我们可以使用寄生式继承方式来继承超类原型，然后将结果指定给子类型的原型。</p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/13430709/68646194-66023080-0555-11ea-936a-676ec58765fe.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/68646206-70242f00-0555-11ea-9365-707e4ceb5d2d.png" alt="image"></p>
<p>call 实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span> (<span class="params">context = &#123;&#125;, ...args</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> res = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数值转换</p>
<p>value -&gt; number，几种方式：Number，parseInt，parseFloat。</p>
<ul>
<li>Number(一元加号操作符效果同 Number 函数)<ul>
<li>if value is <code>boolean</code>, true -&gt; 1,false -&gt; 0</li>
<li>if value is <code>number</code>, value -&gt; value</li>
<li>if value is <code>null</code>, value -&gt; 0</li>
<li>if value is <code>undefined</code>, value -&gt; NaN</li>
<li>if value is <code>string</code><ul>
<li>if stringValue only contains digit(+/- prefix symbol also counts), example:<ol>
<li>“+12” -&gt; 12</li>
<li>“001” -&gt; 1</li>
<li>“-02” -&gt; -2</li>
<li>“+1.2” -&gt; 1.2</li>
<li>“-.2” -&gt; -0.2</li>
</ol>
</li>
<li>if stringValue is valid hexadecimal/binary, turn it to decimal,example:<ol>
<li>“0xf” -&gt; 15</li>
<li>“0b111” -&gt; 7</li>
</ol>
</li>
<li>if stringValue is empty, “” -&gt; 0</li>
<li>if stringValue contains character not mentioned above, return NaN,example:<ol>
<li>“–2” -&gt; NaN</li>
<li>“d2” -&gt; NaN</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ParseInt<br>example：</p>
<ol>
<li>parseInt(“1234ddaa”) -&gt; 1234</li>
<li>parseInt(“”) -&gt; NaN</li>
<li>parseInt(“0xA”) -&gt; 10 // hexadecimal</li>
<li>parseInt(“070”) -&gt; 56 // octal ecma3 version</li>
<li>parseInt(“070”) -&gt; 70 // ecma5 version / strict mode</li>
<li>parseInt(22.2) -&gt; 22.2</li>
<li>parseInt(“d12”) -&gt; NaN</li>
<li>parseInt(“1d12”) -&gt; 1</li>
</ol>
<p>从上述 example4 和 5 可以看到不同版本的 js 引擎解析八进制是不同的，在 ES5 和严格模式下，0 开头的 string 前导 0 会被忽略。</p>
<p>因此 parseInt 可以穿入第二个参数，代表转换成多少进制。example:</p>
<ol>
<li>parseInt(“0xAF”,16) -&gt; 175</li>
<li>parseInt(“AF”,16) -&gt; 175</li>
<li>parseInt(“AF”) -&gt; NaN</li>
<li>parseInt(“10”,2) -&gt; 2</li>
<li>parseInt(“10”, 8) -&gt; 8</li>
<li>parseInt(“10”, 10) -&gt; 10</li>
</ol>
</li>
<li><p>parseFloat(只解析十进制，十六进制的都返回 0)<br>example：</p>
<ol>
<li>parseFloat(“1234ddaa”) -&gt; 1234</li>
<li>parseFloat(“”) -&gt; NaN</li>
<li>parseFloat(“0xFA”) -&gt; 0</li>
<li>parseFloat(“1.2.3”) -&gt; 1.2 // 只解析到第二个小数点前</li>
<li>parseFloat(“.2.3”) -&gt; 0.2</li>
<li>parseFloat(“12.0”) -&gt; 12</li>
<li>parseFloat(“3.125e7”) -&gt; 31250000//科学计数法</li>
</ol>
</li>
</ul>
<hr>
<p>value -&gt; string</p>
<ul>
<li>toString（可传入参数转换为几进制，默认十进制）<br>primitive value example:<ol>
<li>0xAF.toString() -&gt; “175”</li>
<li>0xAF.toString(16) -&gt; “af”</li>
<li>12.toString() -&gt; “12”</li>
<li>12.2.toString() -&gt; “12.2”</li>
<li>0.1.toString(2) -&gt; “0.0001100110011001100110011001100110011001100110011001101”<br>reference value example:</li>
<li>[1,2].toString() -&gt; “1,2”</li>
<li>({}).toString(16) -&gt; “[object Object]” 3. new Set().toString() -&gt; “[object Set]” // new Set()[Symbol.toStringTag] === “Set” 4. new Map().toString() -&gt; “[object Map]” 5. new WeakMap().toString() -&gt; “[object WeakMap]” 6. new WeakSet().toString() -&gt; “[object WeakSet]” 7. Symbol(‘1s’).toString() -&gt; “Symbol(1s)”</li>
</ol>
</li>
<li>String()<br>primitive example:<ol>
<li>String(null) -&gt; “null”</li>
<li>String(true) -&gt; “true”</li>
<li>String(a) -&gt; “undefined”<br>reference value example:<br>same as above.<br>js 中 number 的表示才用了 IEEE754 规范的双精度浮点数（64 位），字节分配如下，分别是 1 位 sign 符号位，11 位 exponent 指数位，52 位 fraction 分数位。<br><img src="https://user-images.githubusercontent.com/13430709/69146908-cbcd5a00-0b0b-11ea-8ed2-a187876ca46e.png" alt="image"><br>经常有讨论 js 精度丢失造成的 0.1+0.2!=0.3 的问题就是缘由此。<br>如下：0.1+0.2 首先会将十进制转换为二进制（十进制小数如何表示为二进制这里不做实现讨论）<br>0.1 -&gt; 0.0001100110011001…(无限循环，需要截取多余位，这里就有精度丢失，对应的双精度 64 位表示为：<br><img src="https://user-images.githubusercontent.com/13430709/69147305-9d9c4a00-0b0c-11ea-8eeb-0e87849b2fe9.png" alt="image"><br>0.2 -&gt; 0.0011001100110011…(无限循环，需要截取多余位，这里就有精度丢失，对应的双精度 64 位表示为：<br><img src="https://user-images.githubusercontent.com/13430709/69147325-a7be4880-0b0c-11ea-92e7-b721981a007d.png" alt="image"><br>然后是两者相加的对阶运算，这里也有精度丢失<br>0.0100110011001100110011001100110011001100110011001100<br>转换为十进制就是 0.30000000000000004，所以不相等。</li>
</ol>
</li>
</ul>
<p>一般处理这种 js 计算精度丢失的问题，原理就是取小数位数的最大数作为放大倍数，将小数放大为整数操作后缩小回去，自己实现考虑的不完善，当然也有第三方库 Math.js,big.js 等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/15/JS-EventLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/15/JS-EventLoop/" itemprop="url">JS EventLoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-15T15:12:14+08:00">
                2021-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>EventLoop</p>
<ul>
<li>浏览器端的是各浏览器厂商对 html5 里的 EventLoop 执行模型规范的实现。</li>
<li>nodeJs 里的是基于 libuv 实现的。</li>
</ul>
<p>MacroTask(task)宏任务</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate（node only）</li>
<li>requestAnimationFrame（web only）</li>
<li>I/O</li>
<li>UI rendering（web only）</li>
</ul>
<p>MicroTask(Job)微任务</p>
<ul>
<li>process.nextTick(node only)</li>
<li>Promise</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<p>web 中 eventLoop 执行流程是： 1.同步的脚本执行完毕后，调用栈清空 2.执行 MicroTask 微任务队列，在此过程中可能会产生新的微任务，比如 promise.resolve().then()里面又产生一个 promise.then 那么新产生的微任务会放在微任务队列的末尾，也在本次执行周期中执行掉。 3.当微任务执行完毕，队列为空后，开始执行宏任务队列的队首的任务（<strong>队首的任务即一个宏任务</strong>），执行完毕后，开始循环回到第二步执行微任务的队列，如此 2，3 两步循环至两个队列和调用栈都为空。<br>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">  resolve(<span class="number">5</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>最终输出为：<br>1 4 10(第一次同步的执行完了)<br>5 6 7 （第一次微任务执行完了）<br>2（第一次宏任务执行完了）<br>3（第二次微任务执行完了）<br>9（第二次宏任务执行完了）<br>8（第三次宏任务执行完了）</p>
<p><img src="https://user-images.githubusercontent.com/13430709/63282738-10194600-c2e2-11e9-85f8-714f0898be6e.png" alt="image"></p>
<p>node 中 eventLoop 就不同了：<br>话不多说，先上 node 官网的 eventloop 图：<br><img src="https://user-images.githubusercontent.com/13430709/63279019-e4df2880-c2da-11e9-83c1-844b38f0412a.png" alt="image"><br>可以看到事件循环宏队列有六个阶段：</p>
<ul>
<li>timers 阶段：执行 setTimeout 和 setInterval 的回调</li>
<li>I/O callback 阶段：执行一些系统调用错误，除了其他几个阶段中的 callback 之外的 callbak，比如 TCP 错误。</li>
<li>idle, prepare 阶段：node 执行过程中的空闲时间,（联想到 window. requestIdleCallback）仅 node 内部使用</li>
<li>poll 阶段：轮询，获取新的 I/O 事件，适当的条件下 node 将阻塞在这里<br>poll 阶段主要两个功能：<ul>
<li>处理 poll 队列的事件</li>
<li>当有已超时的 timer，执行它的回调函数<br>问：如何理解第二点？答：当没有 setImmediate 设置过时 check 阶段就不会进去，那么就一直阻塞在 poll 阶段，这时候 poll 阶段会有一个检查机制。检查 timer 队列是否为空，如果 timer 队列非空，event loop 就开始下一轮事件循环，即重新进入到 timer 阶段。</li>
</ul>
</li>
<li>check 阶段：执行 setImmediate 的回调<ul>
<li>setTimeout 和 setImmediate 的执行顺序是不确定的，依赖于当前主线程是否空闲或者机器上的其他任务。但是如果将两者放在 io 回调里面，即在 poll 阶段之后执行，那么直接进入 check 阶段，即 setImmediate 回调肯定会先执行，然后进入下一个 timmer 回调的执行。）</li>
</ul>
</li>
<li>close callbacks 阶段：执行 socket.on(‘close’, ….)这些回调</li>
</ul>
<p>概括一下，对于我们用户来说主要是四个宏任务队列：</p>
<ol>
<li>timer queue<br>2.io callback queue<br>3.check queue<br>4.close callback queue</li>
</ol>
<p>与此同时，node 还有两个微任务队列：<br>1.precess.nextTick callback queue<br>2.other microtask queue(like promise)</p>
<p>具体的执行顺序是： 1.执行全局同步代码 2.按顺序（先 nextTick callback queue 然后 other microtask queue）执行两个微任务队列中的所有微任务，在此过程中新产生的微任务也会在在本次循环中继续执行知道两个微任务队列都为空，因此会出现所谓的 io starving 的情况（递归调用 process.nextTick）使当前微任务队列一直不为空，一直在执行，io callback 队列永远处于等待的情况，因此官方推荐使用 setImmediate，这样就不会一直被一次的微任务执行卡着。 3.开始执行 macrotask 宏任务，共 6 个阶段，从第 1 个阶段开始执行相应每一个阶段 macrotask 中的所有任务（这里是一个 queue 里的所有任务，同 web 端作区分，web 端是一个 queue 里的首个任务），一个阶段执行完毕之后回到第二步执行两个微任务队列，以此循环。<br><img src="https://user-images.githubusercontent.com/13430709/63282698-f972ef00-c2e1-11e9-97f2-8e5400ab4ee8.png" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/14/隐水印组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/14/隐水印组件/" itemprop="url">隐水印组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-14T21:20:45+08:00">
                2021-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>业务上沉淀的水印组件。</p>
<ol>
<li><p>组件仓库地址：<code>https://github.com/ILovePing/invisible-watermark</code></p>
</li>
<li><p>组件设计<br><img src="https://user-images.githubusercontent.com/13430709/94658082-ef208280-0334-11eb-8878-2d20fe5497cc.png" alt="image"></p>
</li>
<li><p>水印种类</p>
<ol>
<li><p>背景图<br>a. dom 直接插入，平铺在页面 body 上。<br>b. canvas 绘制，导出为 base64 或者 blob 作为元素的 background-image。<br>c. svg 绘制，通过 svg 的 text 元素绘制，最终也是和 canvas 一样转化成 dataUrl 作为元素的背景图。</p>
</li>
<li><p>数字水印<br>参考第三方包实现：digital-watermarking。</p>
</li>
</ol>
</li>
<li><p>封装组件<br>将以上 canvas/svg 绘制水印图片封装成组件形式：invisible-watermark，使用文档见 git readme。</p>
</li>
</ol>
<h3 id="水印攻防"><a href="#水印攻防" class="headerlink" title="水印攻防"></a><strong>水印攻防</strong></h3><ol>
<li><p><strong>攻</strong>常见水印为可见水印，攻击者很容易能避开有水印的位置截图，或者通过控制台将 background-image 注释掉以达到去掉水印的效果。<br><img src="https://user-images.githubusercontent.com/13430709/62448019-4ced2500-b799-11e9-9aa4-0f26145027ac.png" alt="image"></p>
</li>
<li><p><strong>防</strong>针对全局添加额外的一层不可见的隐水印，并添加<a href="https://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="noopener">mutationObserver</a>监听属性变更，使攻击者无法通过控制台简单的注释掉背景水印，对于泄露的数据原图，可通过 ps-&gt;色阶调整可追踪用户信息。<br><img src="https://user-images.githubusercontent.com/13430709/62448978-aa827100-b79b-11e9-9b1e-34efab1c5d69.png" alt="image"></p>
</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/13430709/62448346-2b406d80-b79a-11e9-95d4-80c5d9d5c7b9.png" alt="image"></p>
<ol start="3">
<li><p><strong>攻</strong>攻击者知晓了页面存在不可删除不可注释的水印后，可以通过控制台对存在水印的元素插入 style 覆盖样式。<br><img src="https://user-images.githubusercontent.com/13430709/62448516-9f7b1100-b79a-11e9-85bb-80b1b3ad2a87.png" alt="image"></p>
</li>
<li><p><strong>防</strong>得知攻击者可以通过控制台插入样式，我们尝试阻止攻击者打开控制台。<br>这时候你肯定想到了禁用右键事件，但是别忘了还有快捷键可以打开控制台，难道我们还要禁用掉对应的快捷键吗？（换个热键也能打开），明显不可能。尝试转换方向，控制台可以打开，但是有没有什么办法监听打开事件呢，我们只要能监听到，在打开控制台的时候隐藏掉重要的隐私数据那不就好啦。有如下两个方法：<br> 1. <strong>[适用于大多浏览器，受限于弹出式控制台页面]</strong>控制台打开页面会重新 resize，监听 resize 事件，但是控制台也可以在一个独立的窗口打开，pass<br> 2. <strong>[适用 Chrome 浏览器，受限于非 Chrome 浏览器]</strong>浏览器在打开控制台时会执行 console.log 输出某个对象，这时是会去 get 对象属性的 id，我们可以通过 Object.defineProperty 自定义对象属性 id 的 getter 方法来监听控制台打开。可以了解一下有第三方包专门检测控制台的打开：<a href="https://github.com/AepKill/devtools-detector" target="_blank" rel="noopener">https://github.com/AepKill/devtools-detector</a></p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="keyword">new</span> Image();</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(el, <span class="string">'id'</span>, &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            alert(<span class="string">'控制台打开，隐藏隐私数据'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(el);</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p><strong>攻</strong>不能从控制台插入样式，换个角度：浏览器地址栏支持 javascript 协议，只要是 javascript:开头，后续的 js 语句可以直接执行，攻击者可以通过浏览器地址栏执行 js，插入 style 样式，将所有 div 元素的背景设为 none 即可除掉水印。</p>
</li>
<li><p><strong>攻</strong>无法从控制台入手，攻击者还可以通过 chromium 浏览器内核模拟浏览器访问，通过插入脚本，对访问页面截图导出也可以实现隐藏水印得到数据截图的效果。</p>
</li>
<li><p><strong>防</strong>综上可见，道高一尺魔高一丈，浏览器上直接通过文本渲染的数据肯定是有办法“安全”的拿到的，因此<strong>终极方案就是直接使用 canvas 渲染</strong>，水印直接画在画布上，这样就无法简单的通过 js、css 求水印啦，并且对于图片音频等多媒体文件还可以加上数字水印的方式达到追踪防篡改的效果，可了解一下数字水印的实现原理：<a href="https://www.jianshu.com/p/62e52c4ab5c4" target="_blank" rel="noopener">https://www.jianshu.com/p/62e52c4ab5c4</a>以及 node 实现的 npm 包：<a href="https://github.com/zy445566/node-digital-watermarking" target="_blank" rel="noopener">digital-watermarking</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/14/使用chromeDevTools-Audits-优化web应用实践总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/14/使用chromeDevTools-Audits-优化web应用实践总结/" itemprop="url">使用chromeDevTools Audits 优化web应用实践总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-14T21:17:02+08:00">
                2021-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>提高首屏渲染速度</p>
<ol>
<li><p>Tree shake -&gt; remove unused code</p>
</li>
<li><p>Code split(webpack <code>import</code> / <code>require.ensure</code>) -&gt; load critical code</p>
</li>
<li><p>Script 使用<code>async</code>/<code>defer</code>防止脚本加载会阻塞 dom 渲染（async/defer 异同点，两者都是异步加载，async 是乱序的加载好就马上执行，defer 加载好之后在 html 解析之后按顺序执行，具体见下图）<br>例子：<code>jquery.js</code>可以使用 async 加载，因为它不依赖其他 js，而<code>$(“#id1”).hide()</code>这种依赖 jquery 的 js 应该使用 defer 在 html parse 完成之后加载执行。<br><img src="https://user-images.githubusercontent.com/13430709/62349670-01394200-b533-11e9-9899-b3f9ac5b5c3a.png" alt="484D2E9E-00C9-4C03-B179-3DBB6C5F8A60"><br><img src="https://user-images.githubusercontent.com/13430709/62349681-07c7b980-b533-11e9-96d1-b748e7c0edec.png" alt="CE2D2F28-F6C5-4520-AD5A-C03FEFD3CE4C"><br><code>preload</code>和<code>prefetch</code>这两个是预加载资源到 Http 缓存中，相当于上图里 script fetch 这一步，仔细别搞混淆。</p>
</li>
</ol>
<blockquote>
<p>我们可以明确 DOMContentLoaded 所计算的时间，当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件；如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等位于脚本前面的 css 加载完才能执行。在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。</p>
</blockquote>
<ol start="4">
<li><p>Optimize encoding and transfer size of text-based assets: enable text compression，nginx 静态资源开启 gzip，服务端接口返回数据使用<code>gzip</code>或<code>brotli</code>(Brotli 压缩比优于 gzip)等压缩 response 正文。<br>可通过 Network 里查看请求响应头里的<code>content-encoding</code>有没有<code>gzip/deflate/br</code>字段，和压缩前后 size 大小比较：<br><img src="https://user-images.githubusercontent.com/13430709/62349882-93414a80-b533-11e9-8c0e-17ece1bec786.png" alt="525E22B0-A478-43D0-92C1-0956B7BAB780"></p>
<pre><code>![BB43FCD4-CC5A-4903-8580-B01E6C8990F7](https://user-images.githubusercontent.com/13430709/62349829-7a389980-b533-11e9-8c43-ad8acd8682ac.png)
</code></pre></li>
</ol>
<p>5.Defer critical css ,页面只适合被关键 css（这种关键 css 适合 inline 到 html 里面，减少资源请求的时间）加载阻塞，其他与当前页面展示无关的 css 适合使用 defer 放在。<br>在 Coverage 里可以看到哪些是 critical 资源：<br><img src="https://user-images.githubusercontent.com/13430709/62349945-c7b50680-b533-11e9-9aa2-0e96d378b8ac.png" alt="5DC8DFFC-D660-4A8A-838F-FDBCE2D5DBAD"></p>
<ol start="6">
<li><p>尽量保持主线程空闲，不要长时间阻塞，能及时处理用户输入。</p>
</li>
<li><p>使用服务线程缓存资源，进行计算等，a.防止主线程长时间占用，b.以 httpCache 能力为基准作渐进式增强资源预缓存能力，理想状态无 http 请求往返。<br>使用<code>workbox-webpack-plugin</code> -&gt; use service work to generate thread to load resourses cached. （发布到线上要用 https），具体代码如下：<br><img src="https://user-images.githubusercontent.com/13430709/62350083-33976f00-b534-11e9-854c-4c6d002afeb1.png" alt="image"><br><img src="https://user-images.githubusercontent.com/13430709/62350090-3d20d700-b534-11e9-8716-c6de5a1b5d61.png" alt="image"></p>
</li>
<li><p>减少 redirect 次数，降低多次的 http 往返开销</p>
</li>
<li><p>用户不可见图片不用提前加载；使用适当图片格式，svg 格式是一种挺好的尝试，可以任意 resize 而且 svgcode 作为 text 可以 compress 和 minify；图片使用工具适当压缩；使用多个大小、格式版本的图片资源适配不同场景（<picture> srcset mediaQuery）</picture></p>
</li>
<li><p>图片格式还可以使用最新的 webp，jpeg 2000，jpeg XR，就当作是渐进式增强咯。</p>
</li>
<li><p>TTI -&gt; time to interactive 减少页面加载到可以交互处理用户输入事件的时间长度，防止阻塞页面渲染主要还是防止首屏加载非必要资源，预加载和最小化（压缩混淆）必要资源，预缓存 assets，懒加载其他（未来的）navigation。</p>
</li>
<li><p>运用 Http Cache 的能力。<br><img src="https://user-images.githubusercontent.com/13430709/62350152-6e010c00-b534-11e9-9498-f5ad8fa2d212.png" alt="image"></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/http-header缓存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/http-header缓存/" itemprop="url">http-header缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T18:24:57+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Header缓存"><a href="#Header缓存" class="headerlink" title="Header缓存"></a>Header缓存</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>Q：强缓存没有过失效时间的情况下，如何重新从服务端加载资源？<br>A：更新页面中的资源地址，比如static.js?_v=1f6d7f</p>
<h3 id="Expires（http1-0规范）"><a href="#Expires（http1-0规范）" class="headerlink" title="Expires（http1.0规范）"></a>Expires（http1.0规范）</h3><p>绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT</p>
<h3 id="cache-control（http1-1规范）"><a href="#cache-control（http1-1规范）" class="headerlink" title="cache-control（http1.1规范）"></a>cache-control（http1.1规范）</h3><p>优先级高于Expires</p>
<ul>
<li><p>max-age=<number></number></p>
<p>相对时间，同第一次请求的时间相加计算出过期时间同当前时间比较</p>
</li>
<li><p>no-cache</p>
<p>不使用本地强缓存</p>
</li>
<li><p>no-store</p>
<p>禁止使用浏览器缓存，每次请求资源都需要从服务端取得。</p>
</li>
<li><p>public</p>
<p>可以被所有用户缓存，包括终端用户和cdn等中间代理服务器。</p>
</li>
<li><p>private</p>
<p>只能被终端用户缓存，cdn等中间服务器不能缓存。</p>
</li>
</ul>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>值都是成对出现的，例如：第一次服务端在Header里返回Last-modified字段，那么下次请求发出的时候会带上if-modified-since字段，值就是首次响应头的last-modified值。</p>
<h3 id="if-modified-since"><a href="#if-modified-since" class="headerlink" title="if-modified-since:"></a>if-modified-since:<last-modified></last-modified></h3><p>浏览器发起请求，请求头加上If-Modified-Since：<last-modified>，服务端接受到之后会拿该值同资源在服务器上的最后修改时间作对比，如果没有变化，就返回304，不返回资源，告诉浏览器使用本地的缓存即可；同时因为资源并没有变化，那么响应头并不会返回last-modified，因为同第一次的last-modified相同。如果资源变化了，那么就返回200，资源重新下载，同时返回最新的last-modified。</last-modified></p>
<h3 id="if-none-match"><a href="#if-none-match" class="headerlink" title="if-none-match: "></a>if-none-match: <etag></etag></h3><p>值为资源的一个唯一标识字符串，具体通信策略上同。<br>唯一不同的是304的时候Etag也会返回，即使值相同。<br>同时存在的情况下Etag优先。<br>Q：有last-modified了，为什么还要有etag？<br>A：<br>有些资源变更频率是毫秒级更甚，last-modified颗粒度就到秒为止。<br>有些资源周期性变更，修改时间变了，但是可能文件内容没变，这时候etag相同，返回304，使用本地缓存即可。<br>有些服务器不能精确拿到资源修改时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/13/egg-passport剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/egg-passport剖析/" itemprop="url">egg的passport实现探究</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T11:08:11+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前梳理了目前常见的几种web验证机制，重新回到正题，谈谈egg-passport如何实现验证的。</p>
<p>先看官网对于egg-passport的解释。</p>
<blockquote>
<p>passport plugin for egg, base on passportjs.</p>
<p>Egg 在它之上提供了 egg-passport 插件，把初始化、鉴权成功后的回调处理等通用逻辑封装掉，使得开发者仅需调用几个 API 即可方便的使用 Passport 。</p>
</blockquote>
<p>可以知道egg-passport的核心就是passport，不了解passport，是搞不定egg在其上的封装逻辑的。</p>
<h3 id="passport使用"><a href="#passport使用" class="headerlink" title="passport使用"></a>passport使用</h3><p>我们要把矛头先转向最重要的passport。<br>先了解passport一波：它是node的中间件，可以嵌到express请求前后，用来验证用户身份，可以选择不同的验证方式（strategies），可以定制或选择第三方的验证逻辑，常用的有：Local/Session/Basic/Digest/OpenId/Bearer Strategy几种。local就是使用username和password登录;basic就是之前提到过的常见的base64加密后放到请求头Authentication传输;digest就是弥补basic的安全缺陷设计的密码摘要认证;bear就是基于OAuth2.0的一种验证。</p>
<p>passport最基础的用法如下（以下例子涉及到node服务的都是基于express）：</p>
<p>1.passport初始化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>)</span><br><span class="line">app.use(passport.initialize());</span><br><span class="line">app.use(passport.session());</span><br></pre></td></tr></table></figure>
<p>2.通过passport.use配置本地验证策略，实例化该策略需要传入一个自定义的验证用户信息的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LocalStrategy = <span class="built_in">require</span>(<span class="string">'passport-local'</span>).Strategy;</span><br><span class="line"></span><br><span class="line">passport.use(<span class="keyword">new</span> LocalStrategy(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">username, password, done</span>) </span>&#123;</span><br><span class="line">    User.findOne(&#123; <span class="attr">username</span>: username &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123; <span class="keyword">return</span> done(err); &#125;</span><br><span class="line">      <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">        <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'Incorrect username.'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!user.validPassword(password)) &#123;</span><br><span class="line">        <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'Incorrect password.'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> done(<span class="literal">null</span>, user);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p>3.在express实例路由中使用配置好的passport中间件，/login的post请求进行身份验证，成功失败都指定了跳转地址，如果开启了步骤二中的session配置，那么登录成功之后req.user就保留了登录信息，下次请求就会自动带上sessionId（减少服务端内存占用，一般就是使用一个唯一的sessionId映射用户信息，当服务端拿到req.user时，会通过passport.deserializeUser()去查询用户信息），当然这基本就属于session实现了，这里就不赘述。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/login'</span>,</span><br><span class="line">  passport.authenticate(<span class="string">'local'</span>, &#123;</span><br><span class="line">  successRedirect: <span class="string">'/'</span>,</span><br><span class="line">  failureRedirect: <span class="string">'/login'</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样一个基本的passport验证中间件就应用进去了，那么我们可以看出这个passport关键的就是上面使用到的几个方法：use、initialize、session、authenticate以及strategy部分。好的，那我们就可以带着目标去看看源码里这几个方法都实现了什么能达到这样的效果。</p>
<h3 id="passport探究"><a href="#passport探究" class="headerlink" title="passport探究"></a>passport探究</h3><p>翻看passport包，代码基本都在lib中，我们从index.js入口关键代码开始看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="built_in">module</span>.exports = <span class="keyword">new</span> Passport();</span><br></pre></td></tr></table></figure>
<p>可以看到index文件主要导出了一个实例化的authenticator对象，我们require(“passport”)的就是这个instance对象。<br>我们看下authenticator.js的部分代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SessionStrategy = <span class="built_in">require</span>(<span class="string">'./strategies/session'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Authenticator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._key = <span class="string">'passport'</span>;</span><br><span class="line">  <span class="keyword">this</span>._strategies = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>._serializers = [];</span><br><span class="line">  <span class="keyword">this</span>._deserializers = [];</span><br><span class="line">  <span class="keyword">this</span>._infoTransformers = [];</span><br><span class="line">  <span class="keyword">this</span>._framework = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._userProperty = <span class="string">'user'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line">Authenticator.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.framework(<span class="built_in">require</span>(<span class="string">'./framework/connect'</span>)());</span><br><span class="line">  <span class="keyword">this</span>.use(<span class="keyword">new</span> SessionStrategy());</span><br><span class="line">&#125;;</span><br><span class="line">Authenticator.prototype.framework = <span class="function"><span class="keyword">function</span>(<span class="params">fw</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._framework = fw;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1.初始化执行的两个方法</span></span><br><span class="line">Authenticator.prototype.initialize = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>._userProperty = options.userProperty || <span class="string">'user'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._framework.initialize(<span class="keyword">this</span>, options);</span><br><span class="line">&#125;;</span><br><span class="line">Authenticator.prototype.session = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.authenticate(<span class="string">'session'</span>, options);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2.使用localStrategy的use方法</span></span><br><span class="line">Authenticator.prototype.use = <span class="function"><span class="keyword">function</span>(<span class="params">name, strategy</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!strategy) &#123;</span><br><span class="line">    strategy = name;</span><br><span class="line">    name = strategy.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!name) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Authentication strategies must have a name'</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._strategies[name] = strategy;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3.路由中配置中间件使用的验证方法</span></span><br><span class="line">Authenticator.prototype.authenticate = <span class="function"><span class="keyword">function</span>(<span class="params">strategy, options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._framework.authenticate(<span class="keyword">this</span>, strategy, options, callback);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = Authenticator;</span><br></pre></td></tr></table></figure>
<p>这是部分代码，还有一些原型链上的扩展方法没有贴出来，我们按照我们使用passport步骤看上面使用到的方法。</p>
<ol>
<li>实例化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">2. 使用```initialize()```和```session()```初始化。通过代码不难看出这两个方法最后实际上是调用了一开始赋值给```_framework```的initialize方法和authenticate方法。不难猜出上一点实例化给```_framework```赋的值应该就是一个拥有这两个key的对象。注：initialize方法通过传入```options.userProperty```指定session存放user的key，默认为```user```。</span><br><span class="line">3. 使用```passport.use```配置localStrategy。同1中所述就是再往_strategies对象中存入实例化Strategy，key名为实例的属性name（查看passport-local代码可知此处name为&quot;local&quot;）。</span><br><span class="line">4. 路由接入authenticate验证。ez，还是调用了```_framework```变量的authenticate方法，此处传入的是local的中间件。</span><br><span class="line"></span><br><span class="line">上面过完，更加好奇这个关键的_framework到底存放了啥，也就是connect.js到底返回了啥，接着去看```./framework/connect.js```代码：</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var initialize = require(&apos;../middleware/initialize&apos;)</span><br><span class="line">  , authenticate = require(&apos;../middleware/authenticate&apos;);</span><br><span class="line">exports = module.exports = function() &#123;</span><br><span class="line"></span><br><span class="line">  // HTTP extensions.</span><br><span class="line">  exports.__monkeypatchNode();</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    initialize: initialize,</span><br><span class="line">    authenticate: authenticate</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.__monkeypatchNode = function() &#123;</span><br><span class="line">  var http = require(&apos;http&apos;);</span><br><span class="line">  var IncomingMessageExt = require(&apos;../http/request&apos;);</span><br><span class="line"></span><br><span class="line">  http.IncomingMessage.prototype.login =</span><br><span class="line">  http.IncomingMessage.prototype.logIn = IncomingMessageExt.logIn;</span><br><span class="line">  http.IncomingMessage.prototype.logout =</span><br><span class="line">  http.IncomingMessage.prototype.logOut = IncomingMessageExt.logOut;</span><br><span class="line">  http.IncomingMessage.prototype.isAuthenticated = IncomingMessageExt.isAuthenticated;</span><br><span class="line">  http.IncomingMessage.prototype.isUnauthenticated = IncomingMessageExt.isUnauthenticated;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>ok，30行左右的代码，主要做了三点，对应require了的三个模块：</p>
<ul>
<li><figure class="highlight plain"><figcaption><span>扩展http可读流req接口，增加logIn，logOut，isAuthenticated，isUnauthenticated接口，望名生义, 配置了passport的express对象，req对象里的这几个方法来源于此，此处代码比较长不赘述，可以自行去看实现。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ ```../middleware/initialize``` 一个每次请求到来后都执行passport初始化的中间件。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">module.exports = function initialize(passport) &#123;</span><br><span class="line">  return function initialize(req, res, next) &#123;</span><br><span class="line">  	 // 1.将Authenticator实例赋值给 req._passport.instance</span><br><span class="line">    req._passport = &#123;&#125;;</span><br><span class="line">    req._passport.instance = passport;</span><br><span class="line">	 // 2.将缓存的session赋值给req._passport.session</span><br><span class="line">    if (req.session &amp;&amp; req.session[passport._key]) &#123;</span><br><span class="line">      req._passport.session = req.session[passport._key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><figcaption><span>```  一个每次请求调用都会执行authentic身份认证的中间件，通过闭包的形式返回。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">module.exports = function authenticate(passport, name, options, callback) &#123;</span><br><span class="line">  if (typeof options == &apos;function&apos;) &#123;</span><br><span class="line">    callback = options;</span><br><span class="line">    options = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var multi = true;</span><br><span class="line">  if (!Array.isArray(name)) &#123;</span><br><span class="line">    name = [ name ];</span><br><span class="line">    multi = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return function authenticate(req, res, next) &#123;</span><br><span class="line">  // 确保http的req添加了logIn，logOut等方法扩展</span><br><span class="line">    if (http.IncomingMessage.prototype.logIn</span><br><span class="line">        &amp;&amp; http.IncomingMessage.prototype.logIn !== IncomingMessageExt.logIn) &#123;</span><br><span class="line">      require(&apos;../framework/connect&apos;).__monkeypatchNode();</span><br><span class="line">    &#125;</span><br><span class="line">    //... 下面一堆认证策略的模版代码</span><br><span class="line">    var failures = [];</span><br><span class="line">    function allFailed() &#123;...&#125;</span><br><span class="line">     (function attempt(i) &#123;</span><br><span class="line">      var layer = name[i];</span><br><span class="line">      if (!layer) &#123; return allFailed(); &#125;</span><br><span class="line">      var prototype = passport._strategy(layer);</span><br><span class="line">      if (!prototype) &#123; return next(new Error(&apos;Unknown authentication strategy &quot;&apos; + layer + &apos;&quot;&apos;)); &#125;</span><br><span class="line">      var strategy = Object.create(prototype);</span><br><span class="line">      strategy.success = function(user, info) &#123;...&#125;</span><br><span class="line">      strategy.fail = function(challenge, status) &#123;...&#125;</span><br><span class="line">      strategy.redirect = function(url, status) &#123;...&#125;</span><br><span class="line">      strategy.pass = function() &#123;next();&#125;;</span><br><span class="line">      strategy.error = function(err) &#123;...&#125;</span><br><span class="line">      strategy.authenticate(req, options);</span><br><span class="line">     &#125;)(0);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到模版代码里是遍历name（策略name可以为数组多个），iife的闭包形式自执行，通过<figure class="highlight plain"><figcaption><span>options);```，也就是说这个```authenticate```是策略类自身已经定义好的，ok那我们去看下开头使用的passport-local代码是如何的吧。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>var passport = require(‘passport-strategy’)<br>  , util = require(‘util’)<br>  , lookup = require(‘./utils’).lookup;<br>function Strategy(options, verify) {<br>  if (typeof options == ‘function’) {<br>    verify = options;<br>    options = {};<br>  }<br>  if (!verify) { throw new TypeError(‘LocalStrategy requires a verify callback’); }</p>
<p>  this._usernameField = options.usernameField || ‘username’;<br>  this._passwordField = options.passwordField || ‘password’;</p>
<p>  passport.Strategy.call(this);<br>  this.name = ‘local’;<br>  this._verify = verify;<br>  this._passReqToCallback = options.passReqToCallback;<br>}<br>util.inherits(Strategy, passport.Strategy);<br>Strategy.prototype.authenticate = function(req, options) {<br>  options = options || {};<br>  var username = lookup(req.body, this._usernameField) || lookup(req.query, this._usernameField);<br>  var password = lookup(req.body, this._passwordField) || lookup(req.query, this._passwordField);</p>
<p>  if (!username || !password) {<br>    return this.fail({ message: options.badRequestMessage || ‘Missing credentials’ }, 400);<br>  }</p>
<p>  var self = this;</p>
<p>  function verified(err, user, info) {<br>    if (err) { return self.error(err); }<br>    if (!user) { return self.fail(info); }<br>    self.success(user, info);<br>  }</p>
<p>  try {<br>    if (self._passReqToCallback) {<br>      this._verify(req, username, password, verified);<br>    } else {<br>      this._verify(username, password, verified);<br>    }<br>  } catch (ex) {<br>    return self.error(ex);<br>  }<br>};<br>module.exports = Strategy;<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">看关键代码，一个Strategy函数，原形扩展一个authenticate函数就是上文提到的实例会执行的方法。查看该方法可以看到verified方法里面调用了之前在实例上扩展的success，fail，error模版方法，这个verified方法传给了内置的``<span class="javascript"><span class="string">`_verify</span></span>```变量，而该变量就是我们一开始如何使用passport+localStrategy时传入的方法：</span><br><span class="line"></span><br><span class="line">``<span class="javascript"><span class="string">`javascript</span></span></span><br><span class="line"><span class="javascript">passport.use(<span class="keyword">new</span> LocalStrategy(</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span>(<span class="params">username, password, done</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    User.findOne(&#123; <span class="attr">username</span>: username &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (err) &#123; <span class="keyword">return</span> done(err); &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!user) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'Incorrect username.'</span> &#125;);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!user.validPassword(password)) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="literal">false</span>, &#123; <span class="attr">message</span>: <span class="string">'Incorrect password.'</span> &#125;);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> done(<span class="literal">null</span>, user);</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">));</span></span><br></pre></td></tr></table></figure></p>
<p><strong>这里的done就是verified方法。</strong></p>
<p>可以串联起来，理一下，在new的时候传入一个签名为username，password，done的函数，里面自定义登录的验证逻辑，然后调用done即verified方法，执行对应的定义好的模版代码strategy.sucess/fail/redirect等方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/13/谈谈web身份验证机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/谈谈web身份验证机制/" itemprop="url">理解常见的几种web身份验证类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T11:08:11+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近尝试使用egg-passport-passport接入github登陆，发觉对于OAuth验证的流程不是很清晰，遂整理了一波，顺便了解了下web身份验证的常见技术方案。</p>
<hr>
<p>####前提概念</p>
<ul>
<li><p>Http是无状态的，因此也快速。每次请求都是无关联的。</p>
</li>
<li><p>Https就是在Http协议上加上一层ssl/tls加密，也是stateless的）。</p>
</li>
<li><p>cookie是有状态的，它是存在用户浏览器里的一小坨数据，有一定的失效时间，每次请求会自动带到请求头Cookie字段中。cookie分为内存cookie和硬盘cookie，内存cookie又称为进程cookie，当关闭浏览器即进程关闭cookie就会失效，硬盘cookie则不会。</p>
</li>
<li><p>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群（memcached、redis）、数据库、文件中，作为唯一的标识，用来标记对应的用户，已解决每次请求都是无状态的问题。</p>
</li>
</ul>
<hr>
<p>####常见web身份验证机制<br><strong>HTTP Basic Authentication</strong></p>
<p>http基本身份认证，基本流程如下：</p>
<ol>
<li>客户端访问一个需要身份认证的页面。</li>
<li>服务端响应401（Unauthorized）,并在WWW-Authenticate头部提供如何验证的信息。</li>
<li>如果客户端有意向要验证自己的身份，就在新的请求头部Authorization中添加「用户凭证」。</li>
</ol>
<blockquote>
<p>那么这个用户凭证是怎么生成的呢，公式是<em>base64encode(username+”:”+password)</em>。举个例子，比如输入的用户名是admin，口令密码123456，明文就是”admin:123456”，使用base64加密就是”YWRtaW46MTIzNDU2”。</p>
</blockquote>
<p>当然base64是可逆的，在基本身份认证过程中使用base64并不是为了安全与隐私，而是为将用户名和口令中的不兼容的字符转换为均与HTTP协议兼容的字符集。</p>
<p>优点：非常容易实现，基本所有的浏览器都支持该机制。</p>
<p>缺点：</p>
<ul>
<li>没使用https的话密钥很容易被拦截解码，基本等同于在公共场合脱光了在聊天，因此后来有了一种http摘要认证（使用随机数md5加密），这里不赘述。</li>
<li>除了关闭浏览器，用户没有主动登出的手段。</li>
<li>相较于session认证，因为每次请求头都要有凭证在,所以数据量会大一点。</li>
</ul>
<p><strong>Session Based Authentication</strong></p>
<p>session身份认证这个应该所有人都接触过。session一般使用cookie实现，基本流程如下：</p>
<ol>
<li>第一次用户输入账号密码，http发起请求到服务器。</li>
<li>服务器会生成一个session_id，并将会话保存在数据库/服务器文件/集群上。</li>
<li>然后在响应头把session_id添加到set-Cookie字段里，告诉浏览器把session_id添加到cookie里。</li>
<li>下一次请求发起时，服务器会先去读取请求头Cookie里的session_id存不存在，如果存在那么服务器就会根据session_id去查找存放到session数据/文件，就能识别是哪一个用户了。</li>
<li>如果用户注销，需要发起销毁当前session的请求，服务端销毁session。</li>
</ol>
<p>优点：</p>
<ul>
<li>身份信息不透明。</li>
<li>会话持久化在后台。</li>
<li>可以随时销毁当前会话。</li>
</ul>
<p>缺点：</p>
<ul>
<li>访问量大，服务器压力相对较大。</li>
<li>用户信息可能会丢失。</li>
<li>因为session的实现是依附于浏览器cookie的，所以一旦被人拿到cookie，可能会造成csrf攻击。</li>
</ul>
<p><strong>Token Based Authentication</strong></p>
<p>token令牌验证，随着RESTful API和微服务流行。基本流程如下：</p>
<ol>
<li>用户输入账号密码，发起登录请求。</li>
<li>服务器校验账号密码后，通过一定规则生成token令牌返回给客户端。</li>
<li>客户端保存token到本地存储介质（localStorage、sessionStorage、cookie等）。</li>
<li>客户端发起下次请求时把token带到请求头。</li>
<li>服务端接收到token，解码，如果有效，接受请求。</li>
<li>如果用户注销，客户端销毁本地令牌。</li>
</ol>
<p>可以看出，与session类似，不同的在于session是有状态的，保持在服务端，并通过cookie把会话id保存在客户端；而token是无状态的，只保存在客户端。</p>
<p>优点：</p>
<ul>
<li>无状态，易于扩展，多设备无障碍。</li>
<li>比较安全<br>缺点：</li>
<li>token相较于session_id要长，每次请求头字节更多。</li>
</ul>
<p><strong>JWT</strong></p>
<p>jwt = json web token，就是一种基于token的认证形式。基于web标准，是一种自包含的数据格式，主要有payload和signature。目前有成熟的三方库实现了jwt编码和解码，这里不赘述了。</p>
<p><strong>OAuth</strong></p>
<p>OAuth是一种认证协议，有OAuth 1.0，OAuth 1.0a和OAuth 2.0几个版本。常见的网站使用第三方（比如github，微信，qq）登录都属于OAuth认证。<br>它允许用户通过授权的形式允许第三方应用能访问OAuth服务器上存储的私密资源，而不用将账户密码提供给第三方应用。这么讲挺绕口的，我写起来也绕口，下面简述一下基本流程：</p>
<ol>
<li>用户打开第三方应用选择使用github登录。</li>
<li>页面导向github授权页面，如果没登录github则是输入github账号密码的页面。</li>
<li>用户输入密码后，github会提示是否允许使用github账户登录第三方应用。</li>
<li>用户允许后，OAuth服务会重定向回配置好的第三方应用地址。</li>
<li>这时候该用户在github上的token令牌就发送给了客户端，客户端可以通过token获取用户在github服务器上的资源。</li>
</ol>
<p>说实话一开始接触这个我也觉得挺绕的，这里有一个形象生动的<a href="http://stackoverflow.com/a/32534239" target="_blank" rel="noopener">例子</a>描述了这一过程。英文比较长，简单翻译一下故事情节：</p>
<p>市民小刚想去买土豪李蛋开的甜品店里的甜甜圈，准备使用自己的RMB付钱的时候，李蛋告诉小刚店里只支持银行卡支付，一个甜甜圈要10块钱。小刚贪吃，不嫌麻烦，告诉李蛋那就用自己的工行卡支付，李蛋就在一张纸上写上「李蛋甜品店」，让小刚拿着这张纸去工行。小刚照做（跳转到授权页面），工行柜员小颜看到这张纸上的信息后，要小刚在柜台上提供银行卡号（账号），输入密码（密码），以及要向李蛋支付多少钱，小刚要买10个，确认支付100RMB，柜员小颜这时候在一张白纸上写了一串没人看得懂的火星文（加密的token），告诉小刚确定要付钱给李蛋的话就把这个火星文给李蛋，小刚照做（重定向）。李蛋拿到小明给的火星文后，让小明等一下，自己跑去工行通过火星文获得了小明账户上的100块钱（获取用户授权OAuth服务器上的私密资源），小刚心满意足的拿到10个甜甜圈开始吃了起来。<br>故事并没有结束，之后的每天下班后小刚都去李蛋店里买10个甜甜圈，这次就不用再亲自去银行跑一趟了（已经授权过，没有失效），只要等李蛋去工行取100块钱，就可以直接吃了。</p>
<p>这里我们能明显看出OAuth的一个隐患就是第三方应用如果有token的话随时都可以获取授权资源。</p>
<p>当然优点也显而易见：第三方应用无需获取客户的账号密码就可以获取到用户在OAuth服务器上的资源。</p>
<p><strong>OpenId</strong></p>
<p>维基百科上对OpenId的解释如下：</p>
<blockquote>
<p>OpenID是一个去中心化的网上身份认证系统。对于支持OpenID的网站，用户不需要记住像用户名和密码这样的传统验证标记。取而代之的是，他们只需要预先在一个作为OpenID身份提供者（identity provider, IdP）的网站上注册。OpenID是去中心化的，任何网站都可以使用OpenID来作为用户登录的一种方式，任何网站也都可以作为OpenID身份提供者。OpenID既解决了问题而又不需要依赖于中心性的网站来确认数字身份。</p>
</blockquote>
<p>OpenId的一般登录流程如下：<br>用户A在提供OpenId服务的网站上注册一个openId，接着用户A访问B网站只需要输入这个openId而无需输入账号密码就可以登录。</p>
<p>OpenId的适用场景就是在登录多个网站可以共用一个统一的账户密码,不用换个网站就要重新登录，而OAuth的适用场景就是你在A网站的信息想在B网站使用，然而你不想提供账号密码。<br>但是两者并不是隔离的，两者可以混用。</p>
<p>以上是常用的几种web验证机制，了解了这些之后我开始重新投入egg-passport-github如何实现OAuth验证。且看下文。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/22/深入理解redux之applyMiddleware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈正荣">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Bbb's NoteBook">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/深入理解redux之applyMiddleware/" itemprop="url">深入理解redux之applyMiddleware</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T16:25:36+08:00">
                2017-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一个普通的redux中间件"><a href="#一个普通的redux中间件" class="headerlink" title="一个普通的redux中间件:"></a>一个普通的redux中间件:</h3><p>用了ES6箭头函数和对象解构写法：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>function callTraceMiddleware (&#123;dispatch,getState&#125;)&#123;</span><br><span class="line">    return <span class="attribute">next</span>=&gt; action =&gt;&#123;</span><br><span class="line">        console.trace();</span><br><span class="line">        return next(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等价于ES5写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exports.default = callTraceMiddleware;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callTraceMiddleware</span>(<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dispatch = _ref.dispatch,</span><br><span class="line">        getState = _ref.getState;</span><br><span class="line"><span class="comment">//注意这里嵌套return,函数curry化，本质上就是为了将中间件串联起来执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.trace();</span><br><span class="line">            <span class="keyword">return</span> next(action);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="applyMiddleware使用redux中间件来加强createStore函数："><a href="#applyMiddleware使用redux中间件来加强createStore函数：" class="headerlink" title="applyMiddleware使用redux中间件来加强createStore函数："></a>applyMiddleware使用redux中间件来加强createStore函数：</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">createStore(</span><br><span class="line">	reducer,</span><br><span class="line">	initialState,</span><br><span class="line">	applyMiddleware(</span><br><span class="line">		thunkMiddleware,//常用的异步使用action中间件</span><br><span class="line">		callTraceMiddleware//使用自定义的打印调用栈中间件</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="applyMiddleware实现原理："><a href="#applyMiddleware实现原理：" class="headerlink" title="applyMiddleware实现原理："></a>applyMiddleware实现原理：</h3><p>以下是applyMiddleware.js的源码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> compose <span class="keyword">from</span> <span class="string">'./compose'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> <span class="function">(<span class="params">reducer, preloadedState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer)</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch</span><br><span class="line">    <span class="keyword">var</span> chain = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.applyMiddleware返回了一个匿名闭包函数，在该闭包内使用<code>createStore(reducer, preloadedState, enhancer)</code>创建了store。<br>这样在无数个中间件形成的嵌套函数中共享一个store对象。<br>2.middlewares数组（我们这里为[thunkMiddleware,callTraceMiddleware]）遍历生成新的中间件函数对象数组，每个中间件函数传入middlewareAPI。<br>根据文章开篇的中间件代码可知此时的chain数组里的每个函数对象其实就是入参为next的匿名函数。<br>3.compose方法将chain数组和原生的store.dispatch结合，生成了一个通过一条条都是中间件的流水线加工好的吊吊的新dispatch方法。<br>4.物是人非，至此return给我们的是闭包共享的store对象和一个装备精良的dispatch方法。</p>
<h3 id="我们看到在使用middlewares加工store-dispatch时用到了compose函数，以下是compose的源码设计："><a href="#我们看到在使用middlewares加工store-dispatch时用到了compose函数，以下是compose的源码设计：" class="headerlink" title="我们看到在使用middlewares加工store.dispatch时用到了compose函数，以下是compose的源码设计："></a>我们看到在使用middlewares加工store.dispatch时用到了compose函数，以下是compose的源码设计：</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span><span class="params">(<span class="rest_arg">...funcs</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg =&gt; arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">return</span> (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到compose里关键的地方就是调用了<code>Array.prototype.reduceRight</code>方法。该方法功能就是从右向左执行的reduce函数，详细自行google。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>1. initalValue： lastMiddleware(store.dispatch)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>2. previousValue: composed</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>3. currentValue: currentMiddleware</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>4. return value: currentMiddleware(composed) =&gt; newComposed</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">rest.reduceRight((composed, f) =&gt; f(composed), last(...args))</span><br></pre></td></tr></table></figure></p>
<h3 id="执行过程分析："><a href="#执行过程分析：" class="headerlink" title="执行过程分析："></a>执行过程分析：</h3><p>当前传入中间件为[thunkMiddleware,callTraceMiddleware]。<br>1.chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))<br>上文提到，经过map转换后每一个middleware就变成了<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function (next) &#123;</span><br><span class="line">    <span class="keyword">return</span> function (action) <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.compose(…chain)(store.dispatch)</p>
<p>a. 初始阶段<br><strong>initValue</strong>：composed = callTraceMiddleware(store.dispatch) = function (action) {console.trace();return next(action);}<br><strong>next</strong>: store.dispatch(原生dispatch方法)<br>b. 执行一次<br><strong>currentValue</strong>：thunkMiddleware<br><strong>returnValue</strong>: thunkMiddleware(composed) = thunkMiddleware(callTraceMiddleware(store.dispatch))<br><strong>next</strong>: composed = initValue = callTraceMiddleware(store.dispatch)</p>
<p>所以最后compose执行就是<br>dispatch = thunkMiddleware(callTraceMiddleware(store.dispatch))<br>等价于</p>
<ol>
<li>先执行thunkMiddleware里的逻辑代码，此时next指代为callTraceMiddleware(store.dispatch)</li>
<li>执行callTraceMiddleware,此时next指代为store.dispatch,next(action)等于执行store.dispatch(action)</li>
<li>store.dispatch 会执行 reducer 生成最新的 store 数据</li>
<li>所有next执行完之后return回溯</li>
<li>执行callTraceMiddleware中next后的代码</li>
<li>执行thunkMiddleware中next后的代码<br>总结整个流程就是<br><code>thunkMiddleware-&gt;callTraceMiddleware-&gt;dispatch-&gt;callTraceMiddleware-&gt;thunkMiddleware</code><br>因此整个过程就跟洋葱圈一样从外到里，再从里回溯到外。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="陈正荣">
          <p class="site-author-name" itemprop="name">陈正荣</p>
           
              <p class="site-description motion-element" itemprop="description">陈正荣的博客</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ILovePing" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈正荣</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
