---
title: 深拷贝实现
date: 2021-02-15 15:16:06
tags:
categories: 技术
---

## 拷贝

前言：
ECMAScript 中基本数据类型都是存储在栈中，是有固定字节长度的，由系统自动释放；

引用类型都是存储在堆中，是动态的字节长度，也不会自动释放，引用类型变量值实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址，因此两个引用类型的===比较其实比较的是两者的堆内存地址，就算两个值都是`{a:1}`，但是在内存中的地址是不同的，因此`{a:1} === {a:1}`

so,如下所示，可以看到赋值 a 给 b 的也是一个内存地址而已，ab 两者最终指向的都是一个内存堆，通过任意一个引用值改变内存堆中的原始数值都是会影响另外一个。

```js
var a = {}; // a保存了一个空对象的实例
var b = a; // a和b都指向了这个空对象

a.name = "jozo";
console.log(a.name); // 'jozo'
console.log(b.name); // 'jozo'
```

obviously，你可能会认为这就是最基础的拷贝。NO！这只是引用而已,not copy.
拷贝是将 B 对象拷贝到 A 对象中，而深拷贝和浅拷贝的区别就是两者前者将 B 里面的子对象也拷贝给了 A。如下例子：

```js
function shallowCopy(src) {
  const target = {};
  for (let key in src) {
    if (src.hasOwnProperty(key)) {
      target[key] = src[key];
    }
  }
  return target;
}
const a = { name: "cxq", age: 12, pockets: [1, [2, 3]] };
const b = a;
const c = shallowCopy(a);

b.name = "rick";
b.pockets[0] = 5;
c.age = 99;

console.log(a);
console.log(b);
console.log(c);
```

![image](https://user-images.githubusercontent.com/13430709/69207354-6a000500-0b8a-11ea-9b89-9342e93490ca.png)

c 是浅拷贝 a 的一个新对象，可以看到 c 对象的基本数据类型 age 是一个新的内存栈，因此修改 age 值，a 的 age 值不会跟着变化，同 a 无关联了；而修改 c 对象的 pockets，a、b 对象的属性都被修改了，可见 abc 的 pockets 最终是指向同一个内存堆的。
因此通过浅复制一层 a 得到的 c 对象中的引用类型实际上就是一个内存地址最终指向的是同一个内存堆。

so，想要彻底分离 copy 出来的对象，应当使用深拷贝，即不止第一层，每一层都需要进行拷贝。

```js
function deepClone(src, map = new WeakMap()) {
  if (!isObject(src)) return src; // 基本类型
  const typeTag = Object.prototype.toString.call(src);
  let target = undefined;
  if (isDeepObject.includes(typeTag)) {
    // 可深层嵌套的对象类型
    target = Object.create(Object.getPrototypeOf(src));
  } else {
    return cloneSimpleObject(src, typeTag);
  }
  // 使用weakMap 防止循环引用
  if (map.get(src)) {
    return src;
  } else {
    map.set(src, true);
  }

  if ([mapTag, setTag].includes(typeTag)) {
    const isMap = typeTag === mapTag;
    src.forEach((value) => {
      if (isMap) {
        target.set(key, deepClone(value, map));
      } else {
        target.add(deepClone(value, map));
      }
    });
    return target;
  }
  const keys = typeTag === arrayTag ? undefined : Object.keys(src);
  (keys || src).forEach((value, key) => {
    if (keys) {
      key = value;
    }
    target[key] = deepClone(src[key], map);
  });
  return target;
}

function cloneSimpleObject(src, typeTag) {
  const _constructor = src.constructor;
  switch (typeTag) {
    case numberTag:
    case boolTag:
    case stringTag:
    case errorTag:
    case dateTag:
    case regexpTag:
      return new _constructor(src);
    case symbolTag:
      return Object(Symbol.prototype.valueOf.call(src));
    case funcTag:
      return cloneFunction(src);
  }
}

function cloneFunction(src) {
  // lodash的处理是对于function 直接返回
  // 如果继续深究 可以用正则将params 和 函数体分离出来 使用new Function(...prams,body)生成新实例，如下
  const functionStr = src.toString();
  const bodyReg = /(?<={)(.|\n)+(?=})/m; // 多行匹配 + 后行断言?<= + 先行断言?=
  const paramReg = /(?<=\().+(?=\)\s*{)/;
  if (src.prototype) {
    const params = paramReg.exec(functionStr);
    const bodys = bodyReg.exec(functionStr);
    if (bodys) {
      // 函数体不为空
      if (params) {
        return new Function(
          ...params[0].split(",").map((p) => p.trim()),
          bodys[0]
        );
      }
      return new Function(bodys[0]);
    }
    return null;
  } else {
    // 箭头函数直接eval返回
    return eval(functionStr);
  }
}

const PRIMITIVES = [
  "number",
  "string",
  "boolean",
  "symbol",
  "null",
  "undefined",
]; // 基础类型
/**
 *** 可嵌套对象
 **/
const objectTag = "[object Object]";
const arrayTag = "[object Array]";
const mapTag = "[object Map]";
const setTag = "[object Set]";
const argsTag = "[object Arguments]";
const isDeepObject = [objectTag, arrayTag, mapTag, setTag, argsTag];
/**
 *** 不可嵌套对象
 **/
const regexpTag = "[object RegExp]";
const errorTag = "[object Error]";
const funcTag = "[object Function]";
const dateTag = "[object Date]";
const numberTag = "[object Number]";
const stringTag = "[object String]";
const boolTag = "[object Boolean]";
const symbolTag = "[object Symbol]";

// 还有以下二进制数组类型等，不写了。。。
const arrayBufferTag = "[object ArrayBuffer]";
const dataViewTag = "[object DataView]";
const float32Tag = "[object Float32Array]";
const float64Tag = "[object Float64Array]";
const int8Tag = "[object Int8Array]";
const int16Tag = "[object Int16Array]";
const int32Tag = "[object Int32Array]";
const uint8Tag = "[object Uint8Array]";
const uint8ClampedTag = "[object Uint8ClampedArray]";
const uint16Tag = "[object Uint16Array]";
const uint32Tag = "[object Uint32Array]";

function isObject(src) {
  return src !== null && ["object", "function"].includes(typeof src);
}
```

![deepCopy](https://user-images.githubusercontent.com/13430709/69615178-6fb88780-106f-11ea-9d29-ef8602c5034d.png)
